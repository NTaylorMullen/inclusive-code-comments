/*! (C) Copyright 2020 LanguageTooler GmbH. All rights reserved. */
class LatexParser{static _getLatexCommandArgument(t,e,n=!1){const s=n?"[":"{",a=n?"]":"}";let o=null,r=0,i=!1;for(;;){const n=t[e];if(null===o){if(n===s)o=e;else if(!LatexParser.WHITESPACE_REGEXP.test(n))return null}else{if(!i)if(n===a){if(0===r)break;r--}else n===s&&r++;i="\\"===n}if(++e>=t.length)return null}return{start:o+1,end:e}}static _formatCommand(t,e,n=!0,s=!1){let a=t.commandName;if(s)for(const n of t.optionalArguments){a+=`[${e.substring(n.start,n.end)}]`}if(n)for(const n of t.arguments){a+=`{${e.substring(n.start,n.end)}}`}return a}static getCommentTokens(t){const e=[],n=matchAll(t,this.COMMENT_TOKEN_REGEXP);for(const t of n){const n=t.index+t[1].length,s=t.index+t[0].length;e.push({type:"comment",start:n,end:s})}return e}static getSymbolTokens(t){const e=[],n=matchAll(t,this.SYMBOL_NAMES_REGEXP);for(const s of n){const n=s.index;if(0!==n&&"\\"===t[n-1])continue;const a=s.index+s[0].length,o=s[0];e.push({type:"symbol",start:n,end:a,symbolName:o})}return e}static getSwitchTokens(t){const e=[],n=this.getCommandTokens(t),s=[];for(const t of n)for(const e of t.arguments)s.push(e.start-1);s.sort((t,e)=>t-e);const a=matchAll(t,this.SWITCH_TOKEN_START_REGEXP);for(const n of a){const a=n.index+n[1].length;if(-1!==binarySearchIndex(s,a))continue;let o=n.index+n[0].length,r=0;for(;;){if("{"===t[o]&&"\\"!==t[o-1])r++;else if("}"===t[o]&&"\\"!==t[o-1]){if(0===r)break;r--}if(++o>=t.length){o=-1;break}}if(-1===o)continue;const i=n[2],l=n.index+n[0].length;e.push({type:"switch",start:a,end:o+1,switchName:i,textStart:l,textEnd:o})}return e}static getFormulaTokens(t){const e=[];let n=matchAll(t,this.FORMULA_TOKEN_DOLLARS_REGEXP);for(const t of n){const n=t.index+t[1].length,s=t.index+t[0].length;e.push({type:"formula",start:n,end:s})}const s=this.getCommandTokens(t),a=new Map;let o=null;for(const n of s){const s=this._formatCommand(n,t);this.FORMULA_TOKEN_COMMANDS.some(([t])=>t===s)&&a.set(s,n);const r=this.FORMULA_TOKEN_COMMANDS.find(([t,e])=>e===s);if(r){const t=a.get(r[0]);t?(e.push({type:"formula",start:t.start,end:n.end}),a.delete(r[0])):null===o&&(o=n.end)}}null===o||e.some(t=>t.start<=o)||e.push({type:"formula",start:0,end:o});let r=null;return a.forEach(t=>{(null===r||t.start>r)&&(r=t.start)}),null===r||e.some(t=>t.start>=r)||e.push({type:"formula",start:r,end:t.length}),e.sort((t,e)=>t.start-e.start),e}static getEquationTokens(t){const e=[];let n=matchAll(t,this.EQUATION_TOKEN_DOLLARS_REGEXP);for(const t of n){const n=t.index+t[1].length,s=t.index+t[0].length;e.push({type:"equation",start:n,end:s})}const s=this.getCommandTokens(t),a=new Map;let o=null;for(const n of s){const s=this._formatCommand(n,t);this.EQUATION_TOKEN_COMMANDS.some(([t])=>t===s)&&a.set(s,n);const r=this.EQUATION_TOKEN_COMMANDS.find(([t,e])=>e===s);if(r){const t=a.get(r[0]);t?(e.push({type:"equation",start:t.start,end:n.end}),a.delete(r[0])):null===o&&(o=n.end)}}null===o||e.some(t=>t.start<=o)||e.push({type:"equation",start:0,end:o});let r=null;return a.forEach(t=>{(null===r||t.start>r)&&(r=t.start)}),null===r||e.some(t=>t.start>=r)||e.push({type:"equation",start:r,end:t.length}),e.sort((t,e)=>t.start-e.start),e}static getMathTokens(t){const e=[...this.getFormulaTokens(t),...this.getEquationTokens(t)];return e.sort((t,e)=>t.start-e.start),e}static getCommandTokens(t){const e=[],n=matchAll(t,this.COMMAND_TOKEN_START_REGEXP);for(const s of n){const n=s.index;let a=n+s[0].length;const o=s[0],r=[],i=[];for(;;){let e=this._getLatexCommandArgument(t,a);if(e)r.push(e),a=e.end+1;else{if(!(e=this._getLatexCommandArgument(t,a,!0)))break;i.push(e),a=e.end+1}}e.push({type:"command",start:n,end:a,commandName:o,arguments:r,optionalArguments:i})}return e}}LatexParser.WHITESPACE_REGEXP=/^\s/,LatexParser.COMMENT_TOKEN_REGEXP=/(^|[^\\])%.*/gm,LatexParser.SYMBOL_NAMES_REGEXP=/[~]/g,LatexParser.SWITCH_TOKEN_START_REGEXP=/(^|[^\\]){\s*(\\[a-z]+)\s*/gim,LatexParser.FORMULA_TOKEN_DOLLARS_REGEXP=/(^|[^\\])\$[^]*?[^\\]\$/gm,LatexParser.FORMULA_TOKEN_COMMANDS=[["\\(","\\)"],["\\begin{math}","\\end{math}"]],LatexParser.EQUATION_TOKEN_DOLLARS_REGEXP=/(^|[^\\])\$\$[^]*?[^\\]\$\$/gm,LatexParser.EQUATION_TOKEN_COMMANDS=[["\\[","\\]"],["\\begin{displaymath}","\\end{displaymath}"],["\\begin{equation}","\\end{equation}"],["\\begin{eqnarray}","\\end{eqnarray}"],["\\begin{multline}","\\end{multline}"],["\\begin{multline*}","\\end{multline*}"],["\\begin{gather}","\\end{gather}"],["\\begin{gather*}","\\end{gather*}"],["\\begin{align}","\\end{align}"],["\\begin{align*}","\\end{align*}"],["\\begin{lyxcode}","\\end{lyxcode}"],["\\begin{verbatim}","\\end{verbatim}"],["\\begin{lstlisting}","\\end{lstlisting}"]],LatexParser.COMMAND_TOKEN_START_REGEXP=/\\([^@a-z]|[@a-z]+)\*?/gi,"undefined"!=typeof module&&(module.exports=LatexParser);